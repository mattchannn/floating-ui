# Getting Started

Floating UI is a low-level library for creating "floating"
elements like tooltips, popovers, dropdowns, menus and more.

The library provides two key functionalities:

- **Positioning primitives**: Ensure your floating element is
  positioned optimally in view for the user.
- **Interaction primitives**: Build accessible interactions that
  power floating elements (event listeners, dismissing, ARIA
  attributes, focus trapping, list navigation, and more).

The positioning engine boasts a tiny 600-byte core with strong
tree-shaking support, is extensible through custom middleware,
and can support any platform.

## Install

Choose the package that suits you.

### Vanilla DOM positioning engine

Use with vanilla JavaScript or a non-React framework
([view tutorial](/docs/tutorial)).

```shell
npm install @floating-ui/dom
```

### React DOM positioning engine

Use with React DOM ([view docs](/docs/react-dom)).

```shell
npm install @floating-ui/react-dom
```

### React DOM interactions and positioning engine

Primitive hooks and components, in addition to the positioning
engine, to use with React DOM
([view docs](/docs/floating-interactions)).

```shell
npm install @floating-ui/react-dom-interactions
```

### React Native positioning engine

```shell
npm install @floating-ui/react-native
```

### Canvas or other platforms

Learn about creating a [Platform](/docs/platform).

```shell
npm install @floating-ui/core
```

<details>
  <summary>CDN</summary>

Floating UI can be loaded via CDN using ESM or UMD format.

#### ESM

[Skypack](https://www.skypack.dev/) lets you load ES modules in
the browser:

```html
<script type="module">
  import * as FloatingUIDOM from 'https://cdn.skypack.dev/@floating-ui/dom@__DOM_VERSION__';
</script>
```

Append `?min{:.string}` to the URL in production.

#### Import maps

When working in a low or no build context, it can be useful to
consume code with bare module specifiers, e.g.
`import * from '@floating-ui/dom';{:js}`. In order to do so,
[import maps](https://github.com/WICG/import-maps) clarify the
origin of such a references for the browser.

  <details>
  <summary>JSPM import map example</summary>

```mdx
<script type="importmap">
  {
    "imports": {
      "@floating-ui/dom": "https://ga.jspm.io/npm:@floating-ui/dom@__DOM_VERSION__/dist/floating-ui.dom.esm.js"
    },
    "scopes": {
      "https://ga.jspm.io/": {
        "@floating-ui/core": "https://ga.jspm.io/npm:@floating-ui/core@__CORE_VERSION__/dist/floating-ui.core.esm.js"
      }
    }
  }
</script>
```

JSPM provides a [generator](https://generator.jspm.io/) for
leveraging this API with their CDN.

</details>

#### UMD

```html
<script src="https://unpkg.com/@floating-ui/core@__CORE_VERSION__"></script>
<script src="https://unpkg.com/@floating-ui/dom@__DOM_VERSION__"></script>
```

All exports will be available on `window.FloatingUIDOM{:js}`.

</details>

## Development and production builds

Floating UI is published with default, development, and
production builds, using Node's support for
[export conditions](https://nodejs.org/api/packages.html#packages_conditional_exports).

- `"default"{:js}`: uses `process.env.NODE_ENV{:js}`, in which
  your bundler handles the env variable, dead code elimination,
  and minification
- `"production"{:js}`: minified with no debug logging
- `"development"{:js}`: unminified with debug logging

If you're using a bundler like webpack, Vite, or Parcel, this is
handled for you **automatically**.

If this is not handled, you must opt into one of the builds in
tools that support export conditions. This is done differently
for each tool.

<details>
  <summary>Rollup example</summary>

Using the `@rollup/node-resolve{:.string}` plugin, you can select
the development build with the `exportConditions{:.objectKey}`
option:

```js
import {nodeResolve} from '@rollup/plugin-node-resolve';

export default {
  // ...
  plugins: [
    nodeResolve({
      exportConditions: ['development'],
    }),
  ],
};
```

</details>
